# 05 【绑定样式 条件渲染 列表渲染】

## 1.绑定样式

### 1.1class 样式

写法：:class="xxx" xxx 可以是字符串、对象、数。

所以分为三种写法，字符串写法，数组写法，对象写法

#### 字符串写法

字符串写法适用于：类名不确定，要动态获取。

```vue
<style>
	.normal{
        background-color: skyblue;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            mood:'normal'
        }
    })
</script>
```

#### 数组写法

数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。

```vue
<style>
    .atguigu1{
        background-color: yellowgreen;
    }
    .atguigu2{
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    }
    .atguigu3{
        border-radius: 20px;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
	<div class="basic" :class="classArr">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            classArr: ['atguigu1','atguigu2','atguigu3']
       }
    })
</script>
```

#### 对象写法

对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。

```vue
<style>
    .atguigu1{
        background-color: yellowgreen;
    }
    .atguigu2{
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
	<div class="basic" :class="classObj">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            classObj:{
                atguigu1:false,
                atguigu2:false,
			}
        }
    })
</script>
```

### 1.2style 样式

有两种写法，对象写法，数组写法

#### 对象写法

```html
<!-- 准备好一个容器-->
<div id="root">
	<!-- 绑定style样式--对象写法 -->
	<div class="basic" :style="styleObj">{{name}}</div>
</div>

<script>
	const vm = new Vue({
		el: '#root',
		data: {
			styleObj: {
				fontSize: '40px',
				color: 'red'
			}
		}
	})
</script>
```

#### 数组写法

```html
<!-- 准备好一个容器-->
<div id="root">
	<!-- 绑定style样式--数组写法 -->
	<div class="basic" :style="styleArr">{{name}}</div>
</div>

<script>
	const vm = new Vue({
		el: '#root',
		data: {
			styleArr: [
				{
					fontSize: '40px',
					color: 'blue'
				},
				{
					backgroundColor: 'gray'
				}
			]
		}
	})
</script>
```

## 2.条件渲染

### 2.1v-if

- 写法：

  (1).`v-if`="表达式"

  (2).`v-else-if`="表达式"

  (3).`v-else`="表达式"

- 适用于：切换频率较低的场景，因为不展示的`DOM`元素直接被移除

- 特点：不展示的 DOM 元素直接被移除

- 注意：`v-if`可以和`v-else-if`、`v-else`一起使用，但要求结构不能被“打断”

- `template`标签不影响结构，页面 html 中不会有此标签，但只能配合 v-if，不能配合 v-show

```html
<!-- 准备好一个容器-->
<div id="root">
	<!-- 使用v-if做条件渲染 -->
	<h2 v-if="false">欢迎来到{{name}}</h2>
	<h2 v-if="1 === 1">欢迎来到{{name}}</h2>

	<!-- v-else和v-else-if -->
	<div v-if="n === 1">Angular</div>
	<div v-else-if="n === 2">React</div>
	<div v-else-if="n === 3">Vue</div>
	<div v-else>哈哈</div>

	<!-- v-if与template的配合使用 -->
	<!-- 就不需要写好多个判断，写一个就行 -->
	<!-- 这里的思想就像事件代理的使用 -->
	<template v-if="n === 1">
		<h2>你好</h2>
		<h2>尚硅谷</h2>
		<h2>北京</h2>
	</template>
</div>

<script>
	const vm = new Vue({
		el: '#root',
		data: {
			styleArr: [
				{
					fontSize: '40px',
					color: 'blue'
				},
				{
					backgroundColor: 'gray'
				}
			]
		}
	})
</script>
```

### 2.2v-show

- 写法：v-show="表达式"
- 适用于：切换频率较高的场景
- 特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉(display:none)
- 备注：使用`v-if`的时，元素可能无法获取到，而使用`v-show`一定可以获取到 v-if 是实打实地改变`dom`元素，v-show 是隐藏或显示`dom`元素

```HTML
<!-- 准备好一个容器-->
<div id="root">
    <!-- 使用v-show做条件渲染 -->
    <h2 v-show="false">欢迎来到{{name}}</h2>
    <h2 v-show="1 === 1">欢迎来到{{name}}</h2>
</div>
```

## 3.列表渲染

### 3.1v-for 指令

- 用于展示列表数据
- 语法：`v-for`="**(item, index)** `in` **xxx**" `:key`=**"yyy"**，这里 key 可以是 index，更好的是遍历对象的唯一标识如果 key 写的是 index，前面可以不写 index 也能用
- 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）

```html
<title>基本列表</title>
<script type="text/javascript" src="../js/vue.js"></script>

<div id="root">
	<!-- 遍历数组 -->
	<h3>人员列表（遍历数组）</h3>
	<ul>
		<li v-for="(p,index) of persons" :key="index">{{ p.name }}-{{ p.age }}</li>
	</ul>

	<!-- 遍历对象 -->
	<h3>汽车信息（遍历对象）</h3>
	<ul>
		<li v-for="(value,k) of car" :key="k">{{ value }}--{{ k }}</li>
	</ul>

	<!-- 遍历字符串 -->
	<h3>测试遍历字符串（用得少）</h3>
	<ul>
		<li v-for="(char,index) of str" :key="index">{{ char }}-{{ index }}</li>
	</ul>

	<!-- 遍历指定次数 -->
	<h3>测试遍历指定次数（用得少）</h3>
	<ul>
		<li v-for="(number,index) of 5" :key="index">{{ number }}--{{ index }}</li>
	</ul>
</div>

<script type="text/javascript">
	Vue.config.productionTip = false
	new Vue({
		el: '#root',
		data: {
			persons: [
				{ id: '001', name: '张三', age: 18 },
				{ id: '002', name: '李四', age: 19 },
				{ id: '003', name: '王五', age: 20 }
			],
			car: {
				name: '奥迪A8',
				price: '70万',
				color: '黑色'
			},
			str: 'hello'
		}
	})
</script>
```

![image-20220628123045122](https://i0.hdslb.com/bfs/album/04046d7d90b05b3b05dc3e837066e2297478b7ca.png)

### 3.2key 的作用与原理

1. vue 中的 key 有什么作用？（key 的内部原理）

​ 就是 vue 的虚拟 dom，vue 会根据 data 中的数据生成虚拟 dom，如果是第一次生成页面，就将虚拟 dom 转成真实 dom，在页面展示出来。

2. 虚拟 dom 有啥用？

​ 每次 vm.\_data 中的数据更改，都会触发生成新的虚拟 dom，新的虚拟 dom 会跟旧的虚拟 dom 进行比较，如果有相同的，在生成真实 dom 时，这部分相同的就不需要重新生成，只需要将两者之间不同的 dom 转换成真实 dom，再与原来的真实 dom 进行拼接。我的理解是虚拟 dom 就是起到了一个 dom 复用的作用，还有避免重复多余的操作，下文有详细解释。

3. 而 key 有啥用？

​ key 是虚拟 dom 的标识。

先来点预备的知识：啥是真实 DOM？真实 DOM 和 虚拟 DOM 有啥区别？如何用代码展现真实 DOM 和 虚拟 DOM

#### 真实 DOM 和其解析流程

这里参考超级英雄大佬：https://juejin.cn/post/6844903895467032589

`webkit` 渲染引擎工作流程图

![image-20220628123851994](https://i0.hdslb.com/bfs/album/eeb9be491a9c5e7d2d3d6f1a75fc51349eaf946d.png)

所有的浏览器渲染引擎工作流程大致分为 5 步：创建 `DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`。

- 第一步，构建 DOM 树：当浏览器接收到来自服务器响应的 HTML 文档后，会遍历文档节点，生成 DOM 树。需要注意的是在 DOM 树生成的过程中有可能会被 CSS 和 JS 的加载执行阻塞，渲染阻塞下面会讲到。

- 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；

- 渲染阻塞：当浏览器遇到一个 script 标签时，DOM 构建将暂停，直到脚本加载执行，然后继续构建 DOM 树。每次去执行 Javascript 脚本都会严重阻塞 DOM 树构建，如果 JavaScript 脚本还操作了 CSSOM，而正好这个 CSSOM 没有下载和构建，那么浏览器甚至会延迟脚本执行和构建 DOM，直到这个 CSSOM 的下载和构建。所以，script 标签引入很重要，实际使用时可以遵循下面两个原则：

  - css 优先：引入顺序上，css 资源先于 js 资源

  - js 后置：js 代码放在底部，且 js 应尽量少影响 DOM 构建

    > 还有一个小知识：当解析 html 时，会把新来的元素插入 dom 树里，同时去查找 css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序匹配的例如：div p {...}，会先寻找所有 p 标签并判断它的父标签是否为 div 之后才决定要不要采用这个样式渲染。所以平时写 css 尽量用 class 或者 id，不要过度层叠

- 第三步，构建渲染树：通过 DOM 树和 CSS 规则我们可以构建渲染树。浏览器会从 DOM 树根节点开始遍历每个可见节点(注意是可见节点)对每个可见节点，找到其适配的 CSS 规则并应用。渲染树构建完后，每个节点都是可见节点并且都含有其内容和对应的规则的样式。这也是渲染树和 DOM 树最大的区别所在。渲染是用于显示，那些不可见的元素就不会在这棵树出现了。除此以外，display none 的元素也不会被显示在这棵树里。visibility hidden 的元素会出现在这棵树里。

- 第四步，**渲染布局**：布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

- 第五步，**渲染树绘制**：在绘制阶段，遍历渲染树，调用渲染器的 paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的 UI 后端组件完成的。

**注意点：**

**1、`DOM` 树的构建是文档加载完成开始的？** 构建 `DOM` 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 `HTML` 文档解析完成之后才开始构建 `render` 树和布局。

**2、`Render` 树是 `DOM` 树和 `CSS` 样式表构建完毕后才开始构建的？** 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。

**3、`CSS` 的解析注意点？** `CSS` 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。

**4、`JS` 操作真实 `DOM` 的代价？**传统 DOM 结构操作方式对性能的影响很大，原因是频繁操作 DOM 结构操作会引起页面的重排(reflow)和重绘(repaint)，浏览器不得不频繁地计算布局，重新排列和绘制页面元素，导致浏览器产生巨大的性能开销。直接操作真实`DOM`的性能特别差，我们可以来演示一遍。

```js
<div id="app"></div>
<script>
    // 获取 DIV 元素
    let box = document.querySelector('#app');
    console.log(box);

    // 真实 DOM 操作
    console.time('a');
    for (let i = 0; i <= 10000; i++) {
        box.innerHTML = i;
    }
    console.timeEnd('a');

    // 虚拟 DOM 操作
    let num = 0;
    console.time('b');
    for (let i = 0; i <= 10000; i++) {
        num = i;
    }
    box.innerHTML = num;
    console.timeEnd('b');

</script>
```

![image-20220628123929200](https://i0.hdslb.com/bfs/album/e1d4271fd93c4c197e6284d98c6b40a629ed82df.png)

> 从结果中可以看出，操作真实 DOM 的性能是非常差的，所以我们要尽可能的复用，减少 DOM 操作。

#### 虚拟 DOM 的好处

​ 虚拟 `DOM` 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 `DOM` 的动作，虚拟 `DOM` 不会立即操作 `DOM`，而是将这 10 次更新的 `diff` 内容保存到本地一个 `JS` 对象中，最终将这个 `JS` 对象一次性 `attch` 到 `DOM` 树上，再进行后续操作，避免大量无谓的计算量。所以，用 `JS` 对象模拟 `DOM` 节点的好处是，页面的更新可以先全部反映在 `JS` 对象(虚拟 `DOM` )上，操作内存中的 `JS` 对象的速度显然要更快，等更新完成后，再将最终的 `JS` 对象映射成真实的 `DOM`，交由浏览器去绘制。

​ 虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。

​ 回到最开始的问题，虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 `tag`、`props`、`children` 三个属性。

#### 虚拟 DOM 中 key 的作用

key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】, 随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较，比较规则如下：

- 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：
  - ①.若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM！
  - ②.若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。
- 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key
  - 创建新的真实 DOM，随后渲染到到页面。

#### 用 index 作为 key 可能会引发的问题

**若对数据进行：逆序添加、逆序删除等破坏顺序操作：**

会产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低。

> 案例

```vue
<!-- 准备好一个容器-->
<div id="root">
    <!-- 遍历数组 -->
    <h2>人员列表（遍历数组）</h2>
    <button @click.once="add">添加一个老刘</button>
    <ul>
        <li v-for="(p,index) of persons" :key="index">
            {{p.name}}-{{p.age}}
            <input type="text">
        </li>
    </ul>
</div>

<script type="text/javascript">
Vue.config.productionTip = false

new Vue({
	el: '#root',
	data: {
		persons: [
			{ id: '001', name: '张三', age: 18 },
			{ id: '002', name: '李四', age: 19 },
			{ id: '003', name: '王五', age: 20 }
		]
	},
	methods: {
		add() {
			const p = { id: '004', name: '老刘', age: 40 }
			this.persons.unshift(p)
		}
	}
})
</script>
```

> 解释：

初始数据

persons: [ { id: '001', name: '张三', age: 18 }, { id: '002', name: '李四', age: 19 }, { id: '003', name: '王五', age: 20 } ]

**vue 根据数据生成虚拟 DOM**

初始虚拟 DOM

```html
<li key="0">张三-18<input type="text" /></li>
<li key="1">李四-19<input type="text" /></li>
<li key="2">王五-20<input type="text" /></li>
```

**将虚拟 DOM 转为 真实 DOM**

![image-20220628124433450](https://i0.hdslb.com/bfs/album/196eee2841a1a4b2d6ec45de877483674e22be33.png)

`this.persons.unshift({ id: '004', name: '老刘', age: 40 })`

在 persons 数组最前面添加上 { id: '004', name: '老刘', age: 40 }

新数据：

```js
persons: [
	{ id: '004', name: '老刘', age: 40 },
	{ id: '001', name: '张三', age: 18 },
	{ id: '002', name: '李四', age: 19 },
	{ id: '003', name: '王五', age: 20 }
]
```

**vue 根据数据生成虚拟 DOM**

新虚拟 DOM

```html
<li key="0">老刘-30<input type="text" /></li>
<li key="1">张三-18<input type="text" /></li>
<li key="3">李四-19<input type="text" /></li>
<li key="4">王五-20<input type="text" /></li>
```

**将虚拟 DOM 转为 真实 DOM**

![image-20220628124445501](https://i0.hdslb.com/bfs/album/5c4f5729b0f4e8967181eb7ba611fae3eee658c1.png)

因为老刘被插到第一个，重刷了 key 的值，vue Diff 算法 根据 key 的值 判断 虚拟 DOM 全部发生了改变，然后全部重新生成新的 真实 DOM。实际上，张三，李四，王五并没有发生更改，是可以直接复用之前的真实 DOM，而因为 key 的错乱，导致要全部重新生成，造成了性能的浪费。

**如果结构中还包含输入类的 DOM：**

会产生错误 DOM 更新 ==> 界面有问题。

> 这回造成的就不是性能浪费了，会直接导致页面的错误

![image-20220628124642025](https://i0.hdslb.com/bfs/album/39a8a21073031742edb11bcb6060b378400571dd.png)

#### 总结

- 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值
- 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的

![image-20220628124545127](https://i0.hdslb.com/bfs/album/a1a4de5f3ef005b9c9c8664c5ef583b45cc38777.png)

![image-20220628124559687](https://i0.hdslb.com/bfs/album/b78dff18cb40c097da8c98d356ec10b75c58e2f7.png)

#### 面试题

![image-20220628124831895](https://i0.hdslb.com/bfs/album/c0a1ae671665f4ad3140479eb922b8bf4afac9d3.png)

### 3.3 列表过滤

#### watch 实现

```html
<div id="root">
	<h2>人员列表</h2>
	<input type="text" placeholder="请输入名字" v-model="keyWord" />
	<ul>
		<li v-for="(p,index) of filPersons" :key="p.id"> {{ p.name }}-{{ p.age }}-{{ p.sex }} </li>
	</ul>
</div>

<script type="text/javascript">
	Vue.config.productionTip = false
	// 用 watch 实现
	new Vue({
		el: '#root',
		data: {
			keyWord: '',
			persons: [
				{ id: '001', name: '马冬梅', age: 19, sex: '女' },
				{ id: '002', name: '周冬雨', age: 20, sex: '女' },
				{ id: '003', name: '周杰伦', age: 21, sex: '男' },
				{ id: '004', name: '温兆伦', age: 22, sex: '男' }
			],
			filPersons: []
		},
		watch: {
			keyWord: {
				immediate: true,
				handler(val) {
					this.filPersons = this.persons.filter((p) => {
						return p.name.indexOf(val) !== -1
					})
				}
			}
		}
	})
</script>
```

> 注意:`indexOf`对于空串的结果是 0，这样上面代码初始过滤就是全部数据

#### computed 实现

```html
<div id="root">
	<h2>人员列表</h2>
	<input type="text" placeholder="请输入名字" v-model="keyWord" />
	<ul>
		<li v-for="(p,index) of filPersons" :key="p.id"> {{ p.name }}-{{ p.age }}-{{ p.sex }} </li>
	</ul>
</div>

<script type="text/javascript">
	Vue.config.productionTip = false
	// 用 computed 实现
	new Vue({
		el: '#root',
		data: {
			keyWord: '',
			persons: [
				{ id: '001', name: '马冬梅', age: 19, sex: '女' },
				{ id: '002', name: '周冬雨', age: 20, sex: '女' },
				{ id: '003', name: '周杰伦', age: 21, sex: '男' },
				{ id: '004', name: '温兆伦', age: 22, sex: '男' }
			]
		},
		computed: {
			filPersons() {
				return this.persons.filter((p) => {
					return p.name.indexOf(this.keyWord) !== -1
				})
			}
		}
	})
</script>
```

### 3.4 列表排序

> 有时为了减少服务器压力，能在前端做的尽量在前端做。

```html
<div id="root">
	<h2>人员列表</h2>
	<input type="text" placeholder="请输入名字" v-model="keyWord" />
	<button @click="sortType = 2">年龄升序</button>
	<button @click="sortType = 1">年龄降序</button>
	<button @click="sortType = 0">原顺序</button>
	<ul>
		<li v-for="(p,index) of filPersons" :key="p.id">
			{{p.name}}-{{p.age}}-{{p.sex}}
			<input type="text" />
		</li>
	</ul>
</div>

<script type="text/javascript">
	Vue.config.productionTip = false
	new Vue({
		el: '#root',
		data: {
			keyWord: '',
			sortType: 0, // 0原顺序 1降序 2升序
			persons: [
				{ id: '001', name: '马冬梅', age: 30, sex: '女' },
				{ id: '002', name: '周冬雨', age: 31, sex: '女' },
				{ id: '003', name: '周杰伦', age: 18, sex: '男' },
				{ id: '004', name: '温兆伦', age: 19, sex: '男' }
			]
		},
		computed: {
			filPersons() {
				const arr = this.persons.filter((p) => {
					return p.name.indexOf(this.keyWord) !== -1
				})
				//判断一下是否需要排序
				if (this.sortType) {
					arr.sort((p1, p2) => {
						return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age
					})
				}
				return arr
			}
		}
	})
</script>
```

![image-20220628125312802](https://i0.hdslb.com/bfs/album/ee2733f56f5cb3ebdedf98545974b6a6c1c0cbea.png)
