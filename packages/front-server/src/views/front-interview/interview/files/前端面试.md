# 前端面试

## 盒子模型

在标准模式下的盒模型，盒子实际内容（content）的 width/height=我们设置的 width/height;盒子总宽度/高度=width/height+padding+border+margin

在怪异模式下的盒模型，盒子的（content）宽度+内边距 padding+边框 border 宽度=我们设置的 width(height 也是如此)，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin

## 行内元素 块级元素 行内块元素

行内元素：

- 设置宽高无效，根据内容撑开
- 垂直 margin 无效，水平 margin 有效
- 内边距无效
- 可以和其他行内元素、块级元素共用一行

块级元素：

- 设置宽高有效，宽度默认为父级宽度 100%
- 高度默认根据内容撑开，**没有内容则默认没有高度**
- margin 有效
- 独占一行

行内块元素：

img、input、textarea、button

- 设置宽高有效，自带默认宽高
- margin 有效
- 共用一行

## ajax 步骤

```js
var request = new XMLHttpRequest() // 创建异步对象

request.onreadystatechange = function () {
	// 注册事件
	if (request.readyState == 4) {
		if (request.status == 200) {
			console.log('响应成功')
			console.log(request.responseText)
		} else {
			console.log('响应失败')
		}
	}
}

request.open('GET', 'http://localhost:3000') // 设置请求的参数

// post请求 设置头信息
// request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")

request.send() // 发送请求

// post请求 设置请求主体
// request.send(body)
// request.send("name=v1&upwd=v2")
```

## 图片懒加载

原理：图片是通过`img`的`src属性`，当对 src 赋值时，浏览器会请求图片资源

当 img 元素的 offsetTop<document.body.scrollTop+document.documentElement.offsetHeight

即 img 进入视口的条件成立

基于这个问题，可以利用标签的自定义属性（data-xxx），来保存图片的路径，当需要加载图片时（将要进入视口时），将 data-xxx 赋值给 src 就可以实现按需加载

## CSS3 新特性

grid flex

圆角

媒体查询

子代选择器

过渡 transition

动画 animation

转换 transform

阴影

渐变

## HTML5 新特性

### 一、语义标签

| 标签      | 描述                               |
| --------- | ---------------------------------- |
| <header>  | 定义了文档的头部区域               |
| <footer>  | 定义了文档的尾部区域               |
| <nav>     | 定义文档的导航                     |
| <section> | 定义文档中的节                     |
| <article> | 定义文章                           |
| <aside>   | 定义页面以外的内容                 |
| <details> | 定义用户可以看到或者隐藏的额外细节 |
| <summary> | 标签包含 details 元素的标题        |
| <dialog>  | 定义对话框                         |
| <figure>  | 定义自包含内容，如图表             |
| <main>    | 定义文档主内容                     |
| <mark>    | 定义文档的主内容                   |
| <time>    | 定义日期/时间                      |

### 二、增强型表单

html5 修改一些新的 input 输入特性，改善更好的输入控制和验证

| 输入类型       | 描述                     |
| -------------- | ------------------------ |
| color          | 主要用于选取颜色         |
| date           | 选取日期                 |
| datetime       | 选取日期(UTC 时间)       |
| datetime-local | 选取日期（无时区）       |
| month          | 选择一个月份             |
| week           | 选择周和年               |
| time           | 选择一个时间             |
| email          | 包含 e-mail 地址的输入域 |
| number         | 数值的输入域             |
| url            | url 地址的输入域         |
| tel            | 定义输入电话号码和字段   |
| search         | 用于搜索域               |
| range          | 一个范围内数字值的输入域 |

html5 新增了五个表单元素

| <datalist> | 用户会在他们输入数据时看到域定义选项的下拉列表 |
| ---------- | ---------------------------------------------- |
| <progress> | 进度条，展示连接/下载进度                      |
| <meter>    | 刻度值，用于某些计量，例如温度、重量等         |
| <keygen>   | 提供一种验证用户的可靠方法生成一个公钥和私钥   |
| <output>   | 用于不同类型的输出比如尖酸或脚本输出           |

html5 新增表单属性

| 属性         | 描述                                    |
| ------------ | --------------------------------------- |
| placehoder   | 输入框默认提示文字                      |
| required     | 要求输入的内容是否可为空                |
| pattern      | 描述一个正则表达式验证输入的值          |
| min/max      | 设置元素最小/最大值                     |
| step         | 为输入域规定合法的数字间隔              |
| height/width | 用于 image 类型<input>标签图像高度/宽度 |
| autofocus    | 规定在页面加载时，域自动获得焦点        |
| multiple     | 规定<input>元素中可选择多个值           |

### 三、视频和音频

html5 提供了音频和视频文件的标准，既使用<audio>元素。

音频：<audio src=" "></audio>

```html
<audio controls>
	//controls属性提供添加播放、暂停和音量控件。
	<source src="horse.ogg" type="audio/ogg" />
	<source src="horse.mp3" type="audio/mpeg" />
	您的浏览器不支持 audio 元素。 //浏览器不支持时显示文字
</audio>
```

视频：<video src=" "></video>

```html
<video width="320" height="240" controls>
	<source src="movie.mp4" type="video/mp4" />
	<source src="movie.ogg" type="video/ogg" />
	您的浏览器不支持Video标签。
</video>
```

### 四、Canvas 绘图

### 五、SVG 绘图

### 六、地理定位

使用`getCurrentPosition()`方法来获取用户的位置。以实现“LBS 服务”

```html
<script>
	var x = document.getElementById('demo')
	function getLocation() {
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(showPosition)
		} else {
			x.innerHTML = 'Geolocation is not supported by this browser.'
		}
	}
	function showPosition(position) {
		x.innerHTML = 'Latitude: ' + position.coords.latitude + '<br />Longitude: ' + position.coords.longitude
	}
</script>
```

### 七、拖放 API

拖放是一种常见的特性，即捉取对象以后拖到另一个位置。

在 html5 中，拖放是标准的一部分，任何元素都能够拖放。

```html
<div draggable="true"></div>
```

当元素拖动时，我们可以检查其拖动的数据。

```html
<div draggable="true" ondragstart="drag(event)"></div>
<script>
	function drap(ev) {
		console.log(ev)
	}
</script>
```

| 拖动生命周期 | 属性名      | 描述                                           |
| ------------ | ----------- | ---------------------------------------------- |
| 拖动开始     | ondragstart | 在拖动操作开始时执行脚本                       |
| 拖动过程中   | ondrag      | 只要脚本在被拖动就运行脚本                     |
| 拖动过程中   | ondragenter | 当元素被拖动到一个合法的防止目标时，执行脚本   |
| 拖动过程中   | ondragover  | 只要元素正在合法的防止目标上拖动时，就执行脚本 |
| 拖动过程中   | ondragleave | 当元素离开合法的防止目标时                     |
| 拖动结束     | ondrop      | 将被拖动元素放在目标元素内时运行脚本           |
| 拖动结束     | ondragend   | 在拖动操作结束时运行脚本                       |

### 八、WebWorker

### 九、WebStorage

### 十、WebSocket

## GET POST 请求方式的区别

GET:是从服务器上获取数据，post 是向服务器传送数据

![image-20210309211925410](前端面试.assets/image-20210309211925410.png)

### GET 方法

查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：

- GET 请求保留在浏览器历史记录中
- GET 请求可被收藏为书签
- GET 请求不应在处理敏感数据时使用
- GET 请求有长度限制
- 编码类型 application/x-www-form-urlencoded
- 对数据长度有限制（url 限制 2048 个字符）

### POST 方法

查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：

- 编码类型常见 encodedapplication/x-www-form-urlencoded 或 multipart/form-data
- POST 数据长度无限制
- POST 请求不会保留在浏览器历史记录中

## axios 取消请求

```js
let cancel = null
div.onclick = function () {
	if (cancel !== null) {
		cancel()
	}
	axios({
		method: 'GET',
		url: 'http://localhost:3000/get',
		cancelToken: new axios.CancelToken(function (c) {
			cance = c
		})
	}).then((res) => {
		console.log(res)
		cancel = null
	})
}
```

## 单页面应用和多页面应用

|                   | 单页面应用（SinglePage Web Application，SPA）                           | 多页面应用（MultiPage Application，MPA）     |
| :---------------- | :---------------------------------------------------------------------- | -------------------------------------------- |
| 组成              | 一个外壳页面和多个页面片段组成                                          | 多个完整页面构成                             |
| 资源共用(css,js)  | 共用，只需在外壳部分加载                                                | 不共用，每个页面都需要加载                   |
| 刷新方式          | 页面局部刷新或更改                                                      | 整页刷新                                     |
| url 模式          | a.com/#/pageone a.com/#/pagetwo                                         | a.com/pageone.html a.com/pagetwo.html        |
| 用户体验          | 页面片段间的切换快，用户体验良好                                        | 页面切换加载缓慢，流畅度不够，用户体验比较差 |
| 首屏              | 慢                                                                      | 快                                           |
| 转场动画          | 容易实现                                                                | 无法实现                                     |
| 数据传递          | 容易                                                                    | 依赖 url 传参、或者 cookie 、localStorage 等 |
| 搜索引擎优化(SEO) | 需要单独方案、实现较为困难、不利于 SEO 检索 可利用服务器端渲染(SSR)优化 | 实现方法简易                                 |
| 试用范围          | 高要求的体验度、追求界面流畅的应用                                      | 适用于追求高度支持搜索引擎的应用             |
| 开发成本          | 较高，常需借助专业的框架                                                | 较低 ，但页面重复代码多                      |
| 维护成本          | 相对容易                                                                | 相对复杂                                     |
| 服务器压力        | 小                                                                      | 大，需要负责异步请求和页面合成               |

## ES5 构造函数和 ES6 class 的对比

1. class 不能提升
2. class 只能通过 new 创建实例
3. class 采用严格模式
4. class 的原型上的属性不能被 for of 等遍历

## 延迟加载 JS 的方式

![img](imgs/前端面试.assets/legend.svg)

`<script>`

首先定义没有任何属性的 `<script>`。当 html 文件在解析时，遇到到这样的 js 标签时，会被阻塞，此时，解析将停止，并且将发起一个 js 文件的网络请求（假设这个个 js 标签是个外链 js 文件）。然后在 html 继续解析之前会执行该 js 文件。

![img](imgs/前端面试.assets/893018-20210528001535976-67297434.png)

`<script async>`

**async** 属性会使得 html 解析和 js 文件下载并行执行（不会被阻塞），但是当 js 文件下载完成会立即执行（会阻塞 html 文件解析），**不保证执行顺序（不和在 html 文件中顺序一样，哪个脚本先下载完会先执行）**

![img](imgs/前端面试.assets/893018-20210528001747360-1404120053.png)

`<script defer>`

**defer** 属性会使得 html 解析和 js 文件下载并行执行（不会被阻塞），下载过程同 **async** 属性，会**在 html 完成解析后**再去执行。 **defer** 脚本执行会保证执行顺序（和在 html 文档中顺序保持一致）。

![img](imgs/前端面试.assets/893018-20210528002227152-1571024014.png)

**defer** 脚本会在 DOMContentLoaded 和 load 事件之前执行 。 **async** 脚本会在 load 事件之前发生，但不能保证 DOMContentLoaded 事件先后的执行顺序

## 原型链

![img](前端面试.assets/163a55d5d35b866d~tplv-t2oaga2asx-watermark.awebp)

```js
Function.prototype === Function.__proto__ // true
```

> 函数的`__proto__`指向`Function.prototype`,包括 Function 本身

## 内存泄露

> 指一块被分配的内存未释放或无法释放

1. 意外的全局变量
2. console.log
3. DOM 泄露
4. 闭包
5. 被遗忘的计时器

在传递给`console.log`的对象是不能被垃圾回收，因为在代码运行之后需要在开发工具能查看对象信息。所以最好不要在生产环境中`console.log`任何对象。

## 重绘 回流/重排

![在这里插入图片描述](前端面试.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70.png)

![在这里插入图片描述](前端面试.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70-16453704879177.png)

**浏览器渲染步骤**：

1. 解析 html 生成 DOM 树；解析 css，生成 CSSOM 树，将 DOM 树和 CSSOM 树结合，生成**渲染树**；
2. 布局 render 树（layout、reflow），计算各元素尺寸，位置等
3. 绘制 render 树（painting），绘制页面元素信息
4. 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面

**重绘 reflow**：当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程。如 background-color、visibility、color

**回流/重排 repaint**：当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和 css 具体的大小和位置。

> 请求如下值 offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生 reflow，建议将他们合并到一起操作，可以减少回流的次数。
>
> 回流必然引起重绘，重绘不一定引起回流。

### 如何减少

1. CSS 避免回流和重绘
   - 尽可能在 DOM 树最末端改变 class
   - 避免设置多层内联样式
   - 动画效果应用到 position 属性为 absolute 或 fixed 上
   - 避免使用 table
2. JS 避免回流和重绘
   - 避免使用 JS 多次修改样式，尽量一次性修改完或将样式集成到一个 class 中
   - 尽量使用文档片段创建和操作 DOM（document.createDocumentFragment()）
   - 先隐藏元素，进行修改后再显示元素（display 值为 none 的 DOM 元素不会引起回流、重绘）
   - 避免循环读取 offsetLeft，在循环外保存起来
   - 复杂动画效果使用绝对定位让其脱离文档流，否则会引起父元素、其他元素大量回流

## 浏览器输入 URL 之后发生了什么

![image-20220226235620909](前端面试.assets/image-20220226235620909.png)

Cookie、Session、Token

# JS 面试题

## var、let、const 的区别

1. var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
2. let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
3. const 用来定义常量，使用时必须初始化(即必须赋值)，**只能在块作用域里访问**，而且不能修改。
4. 同一个变量只能使用一种方式声明，不然会报错

[var、let、const 的本质区别是什么 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/373652940)

## 监听元素进入视口

http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html

## 原生拖放

https://www.cnblogs.com/xiaohuochai/p/5886618.html

## 拷贝数组

日常开发中，数组的拷贝是一个会经常遇到的场景。其实实现数组的拷贝有很多骚技巧。

`Array.slice`

```js
const arr = [1, 2, 3, 4, 5]
const copyArr = arr.slice()
```

**展开操作符**

```js
const arr = [1, 2, 3, 4, 5]
const copyArr = [...arr]
```

**使用 `Array` 构造函数和展开操作符**

```js
const arr = [1, 2, 3, 4, 5]
const copyArr = new Array(...arr)
```

`Array.concat`

```js
const arr = [1, 2, 3, 4, 5]
const copyArr = arr.concat()
```

## 数组去重

```js
const arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}]
// => [1, '1', 17, true, false, 'true', 'a', {}, {}]
```

**方法 1：利用 Set**

**缺点：**无法识别相同对象和数组；

```js
const res1 = Array.from(new Set(arr))
```

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

`Set`本身是一个构造函数，用来生成 Set 数据结构。

`Set`函数可以接受一个数组（或者具有` iterable` 接口的其他数据结构）作为参数，用来初始化。

`Array.from()` 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

**方法 2：利用`indexOf includes filter`**

```js
// 缺点：indexOf无法区分NaN;需要特殊处理；
const unique2 = (arr) => {
	const res = []
	for (let i = 0; i < arr.length; i++) {
		if (res.indexOf(arr[i]) === -1) res.push(arr[i])
	}
	return res
}

const unique3 = (arr) => {
	const res = []
	for (let i = 0; i < arr.length; i++) {
		if (!res.includes(arr[i])) res.push(arr[i])
	}
	return res
}

// 缺点：indexOf无法区分NaN;需要特殊处理；
const unique4 = (arr) => {
	return arr.filter((item, index) => {
		return arr.indexOf(item) === index
	})
}

var unique = (arr) => {
	if (!Array.isArray(arr)) return
	return arr.reduce((prev, cur) => (prev.includes(cur) ? prev : [...prev, cur]), [])
}
```

## 箭头函数中，`this`是固定的，不可变的

```js
const obj = {
	a: () => {
		console.log(this.id) // 此处的this指向window
	}
}
var id = '1'
obj.a() // '1'
obj.a.call({
	id: '2'
}) // '1'
```

## 原型链

当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 `__proto__` ）指向它的构造函数的原型对象（`prototype`）。该原型对象也有一个自己的原型对象( `__proto__` ) ，层层向上直到一个对象的原型对象为 `null`。根据定义，`null` 没有原型，并作为这个**原型链**中的最后一个环节。

JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

```js
/**
 * 对应名称
 * prototype:原型
 * __proto__:原型链 链接点
 *
 * 从属关系
 * prototype->函数的一个属性 :对象{}
 * __proto__ ->对象Object的一个属性 :对象{}
 * 对象的__proto__保存着改对象的构造函数的prototype
 */
function Test(params) {
	this.a = 1
	this.b = 333
}
console.log(Test.prototype)

Test.prototype.b = 2

const test = new Test()
console.log(test.__proto__)
console.log(Test.prototype === test.__proto__)

// Test.prototype 也是一个对象,因此它也有__proto__
console.log(Test.prototype.__proto__)
console.log(Object.prototype.__proto__) // 最顶层的__proto__为null

Object.prototype.c = 3

console.log(test)

/**
 * test:{
 *  b:333,
 *  a:1,
 *  __proto__:Test.prototype={
 *    b:2,
 *    __proto__:Object.prototype={
 *      c:3
 *    }
 *  }
 * }
 */
console.log(test.a)
console.log(test.b)
console.log(test.c)

// Function Object : 既是函数又是对象
console.log(Test.__proto__ === Function.prototype) // true

console.log(Function.__proto__)
console.log(Function.prototype)
console.log(Function.__proto__ === Function.prototype) // true 内置规定

// const obj={}
// const obj=new Object()

console.log(typeof Object) // functon
console.log(Object.__proto__ === Function.prototype) // true
console.log(Object.__proto__ === Function.__proto__) // true

// test => {a:1,b:333}
// 不考察原型链
console.log(test.hasOwnProperty('a')) // true
console.log(test.hasOwnProperty('b')) // true
console.log(test.hasOwnProperty('c')) // false

// 考察原型链
console.log('a' in test) // true
console.log('b' in test) // true
console.log('c' in test) // true

// test.constructor -> 实例化test对象的构造函数
console.log(test.constructor === Test)
function Test1(params) {
	this.a = 1111
}
test.constructor = Test1
console.log(test)
console.log(test.__proto__ === Test.prototype)
```

## 防抖 节流

防抖

> 本质上是清除上次定时器，重新声明一个新的定时器

```js
const debounce = (func, wait, ...args) => {
	let timeout
	return function () {
		const context = this
		if (timeout) clearTimeout(timeout)
		timeout = setTimeout(() => {
			func.apply(context, args)
		}, wait)
	}
}
```

```js
// 第一次函数一定执行，不会被第二次覆盖掉
const debounce = (func, wait, ...args) => {
	let timeout
	return function () {
		const context = this
		if (timeout) cleatTimeout(timeout)
		let callNow = !timeout
		timeout = setTimeout(() => {
			timeout = null
		}, wait)

		if (callNow) func.apply(context, args)
	}
}
```

```js
let Debounce = function (fn, delay = 300, immediate = false) {
	let timer = null // 闭包存储setTimeout状态
	return function () {
		let self = this // 事件源this
		let args = arguments // 接收事件源的event
		if (timer) {
			clearTimeout(timer) // 清除定时器,timer变量仍然保存着计时器ID
		} // 存在就清除执行fn的定时器
		if (immediate) {
			// 立即执行
			let callNow = !timer // 执行fn的状态
			console.log(`callNow: `, callNow)
			timer = setTimeout(function () {
				timer = null
			}, delay)
			if (callNow) fn.apply(self, args)
		} else {
			// 非立即执行
			timer = setTimeout(function () {
				// 或者使用箭头函数将this指向dom
				fn.apply(self, args)
			}, delay)
		}
	}
}

let con1 = document.querySelector('.con1')
let con2 = document.querySelector('.con2')
let con3 = document.querySelector('.con3')

let addNum = function (args) {
	console.log('addnum')
	// console.log(this, args)
	// this.innerText = (+this.innerText) + 1
}

con1.onclick = addNum // 无防抖

con2.onclick = Debounce(addNum) // 防抖

con3.onclick = Debounce(addNum, 300, true) // 防抖（立即执行）
```

节流

> 节流不需要 clearTimeout

```js
const throttle = (func, wait, ...args) => {
	let pre = 0
	return function () {
		const context = this
		let now = +Date.now()
		if (now - pre >= wait) {
			func.apply(context, args)
			pre = now
		}
	}
}
```

```js
const throttle = (func, wait, ...args) => {
	let timeout
	return function () {
		const context = this
		if (!timeout) {
			timeout = setTimeout(() => {
				timeout = null
				func.apply(context, args)
			}, wait)
		}
	}
}
```

```js
// 是否立即执行
let ThrottlePro = function (fn, delay = 500, immediate = false) {
	let preTime = 0 // 记录上一次执行时间
	return function () {
		let self = this, // 保留执行时候的的this
			args = [...arguments], // 执行时候的传入参数
			nowTime = +new Date(), // 记录当前的时间
			flag = nowTime - preTime >= delay // 执行命令
		if (immediate) {
			// 是否立即执行
			if (!flag) return
			preTime = nowTime // 更新执行时间
			fn.apply(self, args)
		} else {
			if (!flag) return // 不满足执行条件
			preTime = nowTime
			setTimeout(function () {
				fn.apply(self, args)
			}, delay)
		}
	}
}
```

## event loop

每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。

```
宏任务 → 所有微任务 → 下一个宏任务
```

```js
题 1：

setTimeout(function () {
    console.log(1)
});
new Promise(function(resolve,reject){
    console.log(2)
    resolve(3)
}).then(function(val){
    console.log(val)
})
console.log(4)

Result:
2 → 4 → 3 → 1
```

```js
题 2：

new Promise(resolve => {
    resolve(1);

    Promise.resolve().then(() => {
    	// t2
    	console.log(2)
    });
    console.log(4)
}).then(t => {
	// t1
	console.log(t)
});
console.log(3);

Result:
4 → 3 → 2 → 1
```

## valueOf 和 toString

### valueOf 转换规则

非原始值(也就是对象)重写规则如下：

| 对象     | valueOf 返回值       |
| -------- | -------------------- |
| Array    | 数组本身             |
| Boolean  | 布尔值               |
| Date     | 返回毫秒形式的时间戳 |
| Function | 函数本身             |
| Number   | 数字值               |
| Object   | 对象本身             |
| String   | 字符串值             |

#### 对象转换为布尔值

1. 直接转换为 true（包装类型也一样），不调用 valueOf 和 toString

#### 对象转换为数字

在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用 valueOf 和 toString 方法，具体规则如下：

1. 如果对象具有`valueOf`方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回 NaN)，并返回这个数字
2. 如果对象具有`toString`方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回 NaN)，并返回这个数字
3. 转换失败，抛出`TypeError`

#### 对象转换为字符串

1. 如果对象具有`toString`方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串
2. 如果对象具有`valueOf`方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串
3. 转换失败，抛出`TypeError`

### toString 转换规则

| 对象     | toString 返回值                                                        |
| -------- | ---------------------------------------------------------------------- |
| Array    | 以逗号分割的字符串，如[1,2]的 toString 返回值为"1,2"                   |
| Boolean  | "true"                                                                 |
| Date     | 可读的时间字符串，如"Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)" |
| Function | 声明函数的 JS 源代码字符串                                             |
| Number   | "数字值"                                                               |
| Object   | "[object Object]"                                                      |
| String   | "字符串"                                                               |

### 面试题

```
var a = {};
var b = {};
var c = {};
c[a] = 1;
c[b] = 2;

console.log(c[a]);
console.log(c[b]);
复制代码
```

### 题解

由于对象的 key 是字符串，所以`c[a]`和`c[b]`中的`a`和`b`会执行[对象到字符串]的转换。

根据转换规则, `a`和`b`都转换为了`[object Object]`，所以`c[a]`和`c[b]`操作的是同一个键。

答案是`输出两个2`，c 对象的最终结构如下：

```
{
  '[object Object]':2
}
```

## 函数累加

问题：用 `JS `实现一个无限累加的函数 `add`，示例如下：

```js
add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)； // 6
add(1)(2)(3)(4)； // 10
// 以此类推
```

```js
function add(a) {
	function sum(b) {
		// 使用闭包
		a = b ? a + b : a // 累加
		return sum
	}
	sum.toString = function () {
		// 重写toSting() 方法 把结果a返回出去
		return a
	}
	return sum // 返回一个函数
}
```

> `add()`每次都会返回一个函数`sum`，直到最后一个没被调用，默认会触发`toString`方法，所以我们这里重写`toString`方法，并返回累计的最终值`a`

当一个对象转换成原始值时，先查看对象是否有`valueOf`方法，如果有并且返回值是一个原始值，则直接返回这个值；如果没有`valueOf`或返回的不是原始值，那么调用`toString`方法，返回字符串表示。

```js
function add() {
	// 1 把所有参数转换成数组
	let args = Array.prototype.slice.call(arguments)
	// 2 再次调用add函数，传递合并当前与之前的参数
	let fn = function () {
		let arg_fn = Array.prototype.slice.call(arguments)
		return add.apply(null, args.concat(arg_fn))
	}
	// 3 最后默认调用，返回合并的值
	fn.toString = function () {
		return args.reduce(function (a, b) {
			return a + b
		})
	}
	return fn
}

// ES6写法
function add() {
	let args = [...arguments]
	let fn = function () {
		return add.apply(null, args.concat([...arguments]))
	}
	fn.toString = () => args.reduce((a, b) => a + b)
	return fn
}
```

## 函数默认参数的作用域

1. 普通情况下，a b c 都在局部作用域里

![image-20211228231110477](JS面试题.assets\image-20211228231110477.png)

2. 函数参数有默认值时，a b 在局部作用域里，c 在块作用域里

![image-20211228232240876](JS面试题.assets\image-20211228232240876.png)

3. 函数形参和函数体内都声明了同一个变量名的变量 a，代码执行第 16 行时，块级作用域中 a 的值取自局部作用域中 a 的值。

   代码执行第 13 行时，块作用域中 a 的值为 7，局部作用域中 a 的值为 1。

   如果进入函数时，局部作用域形参有默认值则会给块作用域中同名的变量赋默认值。

![image-20220101215340845](JS面试题.assets\image-20220101215340845.png)

![image-20220101215812796](JS面试题.assets\image-20220101215812796.png)

```html
<script>
	var x = 1
	function test(
		x,
		y = function () {
			x = 3
			console.log(x)
		}
	) {
		/*
      局部作用域Local
      x => undefined => 3
      y => function(){x=3;console.log(x)} // 第2个输出:3

    */

		/*
        块作用域 Block
        x => undefined => 2
      */
		console.log(x) // 第1个输出:undefined
		var x = 2
		y()
		console.log(x) // 第3个输出:2
	}
	test()
	console.log(x) // 第4个输出:1
</script>
```

```html
<script>
	var x = 1
	function test(
		x = 4,
		y = function () {
			x = 3
			console.log(x)
		}
	) {
		/*
      局部作用域Local
      x => 4 => 3
      y => function(){x=3;console.log(x)} // 第2个输出:3
    */

		/*
        块作用域 Block
        x => 4 => 2
      */
		console.log(x) // 第1个输出:4
		var x = 2
		y()
		console.log(x) // 第3个输出:2
	}
	test()
	console.log(x) // 第4个输出:1
</script>
```

```html
<script>
	/*
    全局作用域 Global
    x => 1 => 3
  */
	var x = 1
	function test(
		a,
		y = function () {
			x = 3
			console.log(x)
		}
	) {
		/*
      局部作用域Local
      a => undefined
      y => function(){x=3;console.log(x)} // 第2个输出:3
    */

		/*
        块作用域 Block
        x => undefined
      */
		console.log(x) // 第1个输出:undefined
		var x = 2
		y()
		console.log(x) // 第3个输出:2
	}
	test()
	console.log(x) // 第4个输出:3
</script>
```

```html
<script>
	/*
    全局作用域 Global
  */
	var x = 1
	function test(
		x,
		y = function () {
			x = 3
			console.log(x)
		}
	) {
		/*
      局部作用域Local
      x => undefined => 3
      y => function(){x=3;console.log(x)} // 第2个输出:3
    */

		/*
        块作用域 Block
      */
		console.log(x) // 第1个输出: undefined
		// var x=2
		y()
		console.log(x) // 第3个输出:3
	}
	test()
	console.log(x) // 第4个输出:1
</script>
```

```html
<script>
	/*
    全局作用域 Global
    x => 1 => 3
  */
	var x = 1
	function yy() {
		x = 3
		console.log(x) // 第2个输出:3
	}
	function test(x, y = yy) {
		/*
      局部作用域 Local
      x => undefined
      y => yy
    */

		/*
        块作用域 Block
        x => undefined => 2
      */
		console.log(x) //  第1个输出:undefined
		var x = 2
		y()
		console.log(x) // 第3个输出:2
	}
	test()
	console.log(x) // 第4个输出:3
</script>
```

## new 做了什么事情

1. 创建一个空对象
2. 将空对象的原型指向构造函数的原型对象
3. 执行时将构造函数内部的 this 指向空对象

## typeof instanceof toString

![image-20220215103036235](JS面试题.assets\image-20220215103036235.png)

在 javascript 的最初版本中，使用的 32 位系统，为了性能考虑使用低位存储了变量的类型信息：

- 000：对象
- 010：浮点数
- 100：字符串
- 110：布尔
- 1：整数

对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的。

`null`：对应机器码的 NULL 指针，一般是全零

`undefined`：用 −2^30 整数来表示

所以，`typeof` 在判断 `null` 的时候就出现问题了，由于 `null` 的所有机器码均为 0，因此直接被当做了对象来看待。

### typeof 返回值

- "undefined"
- "object"
- "boolean"
- "number"
- "bigint"
- "string"
- "symbol"
- "function"

```js
typeof null // 'object'
typeof undefined // "undefined"
typeof false // "boolean"
typeof 1 // "number"
typeof '1' // "string"
typeof {} // "object"
typeof [] // "object"
typeof new Date() // "object"
typeof Symbol() // "Symbol"
typeof 123n // 'bigint'
typeof function foo() {} // 'function'
```

### instanceof

**instanceof** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

#### 手写 instanceof

```javascript
function my_instance_of(leftVaule, rightVaule) {
	if (typeof leftVaule !== 'object' || leftVaule === null) return false
	let rightProto = rightVaule.prototype,
		leftProto = leftVaule.__proto__
	while (true) {
		if (leftProto === null) {
			return false
		}
		if (leftProto === rightProto) {
			return true
		}
		leftProto = leftProto.__proto__
	}
}
```

### toString

```js
var toString = Object.prototype.toString

console.log(toString.call(und)) // [object Undefined]
console.log(toString.call(nul)) // [object Null]
console.log(toString.call(boo)) // [object Boolean]
console.log(toString.call(num)) // [object Number]
console.log(toString.call(str)) // [object String]
console.log(toString.call(obj)) // [object Object]
console.log(toString.call(arr)) // [object Array]
console.log(toString.call(fun)) // [object Function]
console.log(toString.call(date)) // [object Date]
console.log(toString.call(reg)) // [object RegExp]
console.log(toString.call(err)) // [object Error]
console.log(toString.call(arg)) // [object Arguments]
```

- 使用 typeof 来判断基本数据类型是可行的,需要注意的是 typeof 判断 null 类型时的问题
- 判断一个对象考虑用 instanceof，但是 instanceof 判断一个数组的时候,它可以被 instanceof 判断为 Object
- 比较准确的的判断对象实例的类型，采取`Object.prototype.toString.call()`方法

## javascript 编程题

浏览器下：

```js
// 最终结果 10 10 10 undefined

var obj = {
	age: 18,
	foo: function (func) {
		func() // window.func() 由window调用
		let zz = arguments[0] // window.func() 由window调用
		zz()
		arguments[0]() // arguments.0() 由arguments调用
	}
}
var age = 10
function temp() {
	console.log(this.age)
}
temp() // window.func() 由window调用

obj.foo(temp)
```

闭包

```js
// 最终结果 11 12 0
var n = 0
function a() {
	var n = 10
	function b() {
		n++ // 10+1
		console.log(n) // 11
	}
	b()
	return b
}
var c = a()
c() // 12
console.log(n) //0
```

```js
var a = 10
var b = 11
var c = 12
function test(a) {
	// 形参等同于var a
	a = 1
	var b = 2
	c = 3
}
test(100)
console.log(a) // 10
console.log(b) // 11
console.log(c) // 3
```

html 下：

```js
var num = 10
var obj = { num: 20 }
obj.fn = (function (num) {
	this.num = num * 3 // 20*3
	num++ // 20+1
	return function (n) {
		this.num += n // 5+20*3  // obj.fn(10) 此时this.num指向obj.num 20+10
		num++ // 20+1+1  // 闭包,此处num指向外层匿名函数的num 22+1
		console.log(num) // 22  // 23
	}
})(obj.num) // 20

var fn = obj.fn
fn(5) // window.fn() 输出 22
obj.fn(10) // 输出 23
console.log(num, obj.num) // 65 30
```

第三行匿名函数自调用，传入实参 20，此时函数内的`this.num`指向全局下的`num`

html 下：

```js
let obj = {
	age: 20,
	info: function () {
		return () => {
			console.log(this.age)
		}
	}
}
let person = { age: 28 }
let info1 = obj.info()
info1() // 20
let info2 = obj.info.call(person)
info2() // 28
```

**箭头函数不能在 call 方法修改里面的 this**

函数的 this 可以通过 call 等显式绑定的方式修改，而为了减少 this 的复杂性，箭头函数无法用 call()来指定 this

```js
const obj = {
	a: () => {
		console.log(this)
	}
}
obj.a.call('123') //打出来的结果依然是window对象
```

不管我们给函数进行几次 bind 显式绑定，函数中的 this 永远由 **第一次 bind** 决定

```js
let a = {}
let fn = function () {
	console.log(this)
}
fn.bind().bind(a)() // => Window
```

```js
var a = 1
let b = 1
const c = 1
console.log(window.a) // 1
console.log(window.b) // undefined
console.log(window.c) // undefined

在全局作用域下使用let和const声明变量，变量并不会被挂载到window上，这一点与var不同

关于const，还有两个注意点：
- const声明之后必须马上赋值，否则报错
- const简单类型一旦声明就不能修改，而复杂类型（数组，对象）指针指向的地址不能修改，但内部数据可以修改
```

```html
<script>
	let a = {}
	b = '0'
	c = 0
	a[b] = '1'
	a[c] = 2
	console.log(a[b]) // 2
</script>
```

```html
<script>
	let a = {}
	b = {
		n: '0'
	}
	c = {
		m: '2'
	}
	a[b] = 'qaz'
	a[c] = 'abc'
	console.log(a[b]) // 'abc'
</script>
```

```html
<script>
	var test = (function (i) {
		return function () {
			alert(i * 2)
		}
	})(2)
	test(5) // '4' alert默认调用.toString()
</script>
```

```html
<script>
	var a = 0,
		b = 0
	function A(a) {
		A = function (b) {
			alert(a + b++) // a闭包
		}
		alert(a++)
	}
	A(1) // '1'
	A(2) // '4'
</script>
```

# Vue 面试题

## MVVM 响应式原理

**几种实现双向绑定的做法**

目前几种主流的 mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textarea 等）添加了 change(input)事件，来动态修改 model 和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。

实现数据绑定的做法有大致如下几种：

> 发布者-订阅者模式（backbone.js）
>
> 脏值检查（angular.js）
>
> 数据劫持（vue.js）

**数据劫持:** vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

dep(订阅器/数据依赖） watcher（订阅者/观察者）

![img](MVVM响应式原理.assets\172970655167cff7)

实现指令解析器 Compile
