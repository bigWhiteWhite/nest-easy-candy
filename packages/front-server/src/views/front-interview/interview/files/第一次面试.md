## 圣杯布局

**3 个区域都浮动，加一个父元素清除浮动，主区域要优先加载，所以主区域放在第一个子元素的第一个，父元素加了一个 0,100px 的 padding，然后给主区域宽度设置为 100%，这样做就让主区域居中了**。

**给左区域设置一个 margin-left 为负的 100%，因为 3 个子元素都浮动了起来，所以左区域盒子是参照主区域盒子来进行 margin-left 的，所以左区域盒子只能在主区域的左侧，挡住了左区域，右区域也一样**

**设置相对定位，将两个区域移开**

### 基本流程

- 父元素中的 3 个子元素，middle 在第一个，3 个子元素浮动，父元素清除浮动

- 父元素加 padding，主区域居中，left 加 margin-left:-100%，right 加 margin-left 为自身宽度，然后就会挡住主区域

- left，right 加相对定位，移出主区域

**父元素的左 padding 要等于 left 的宽度，右 padding 要等于 right 的宽度，为他们腾出位置**

## 双飞翼布局

### 基本流程

- 父元素中的 3 个子元素，middle 在第一个，3 个子元素浮动，父元素清除浮动

- left 加 margin-left:-100%，right 加 margin-left 为自身宽度，然后就会挡住主区域

- m_inner 加 padding:0 200px，或者 margin:0 200px，目的都是让主区域的内容不被挡住，200px 为左右区域的宽度

**双飞翼布局和圣杯布局的对比**

​ 1.两种布局方式都是将主列放在文档流最前面，是主列优先加载

​ _2.两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。_

​ _3.两种布局方式的不同之处在于如何处理中间主列的位置_

​ 圣杯布局是利用父容器的左，右内边距+两个从列相对定位

​ 双飞翼布局是利用 m_inner 的 padding 或者 margin 改变边距，没有利用父元素

## flex 实现

​ **父元素为 flex，左右区域设置为固定的宽度，主区域设置为 flex:1**

## 虚拟 dom

### 一、什么是虚拟 DOM

虚拟 DOM （`Virtual DOM` ）这个概念相信大家都不陌生，从 `React` 到 `Vue` ，虚拟 `DOM` 为这两个框架都带来了跨平台的能力（`React-Native` 和 `Weex`）

实际上它只是一层对真实`DOM`的抽象，以`JavaScript` 对象 (`VNode` 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上

在`Javascript`对象中，虚拟`DOM` 表现为一个 `Object `对象。并且最少包含标签名 (`tag`)、属性 (`attrs`) 和子元素对象 (`children`) 三个属性，不同框架对这三个属性的名命可能会有差别

创建虚拟`DOM`就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟`DOM`对象的节点与真实`DOM`的属性一一照应

在`vue`中同样使用到了虚拟`DOM`技术

定义真实`DOM`

```
<div id="app">
    <p class="p">节点内容</p>
    <h3>{{ foo }}</h3>
</div>
```

实例化`vue`

```
const app = new Vue({
    el:"#app",
    data:{
        foo:"foo"
    }
})
```

观察`render`的`render`，我们能得到虚拟`DOM`

```
(function anonymous(
) {
	with(this){return _c('div',{attrs:{"id":"app"}},[_c('p',{staticClass:"p"},
					  [_v("节点内容")]),_v(" "),_c('h3',[_v(_s(foo))])])}})
```

通过`VNode`，`vue`可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过`diff`算法得出一些需要修改的最小单位,再更新视图，减少了`dom`操作，提高了性能

### 二、为什么需要虚拟 DOM

`DOM`是很慢的，其元素非常庞大，页面的性能问题，大部分都是由`DOM`操作引起的

真实的`DOM`节点，哪怕一个最简单的`div`也包含着很多属性，可以打印出来直观感受一下： [![img](https://camo.githubusercontent.com/234fc4ad83ae7be48326d778828c2f532828e57201c8db86ccb4fcd71cd8184a/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63633935633766302d343432632d313165622d616239302d6439616538313462323430642e706e67)](https://camo.githubusercontent.com/234fc4ad83ae7be48326d778828c2f532828e57201c8db86ccb4fcd71cd8184a/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63633935633766302d343432632d313165622d616239302d6439616538313462323430642e706e67)

由此可见，操作`DOM`的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验

**举个例子：**

你用传统的原生`api`或`jQuery`去操作`DOM`时，浏览器会从构建`DOM`树开始从头到尾执行一遍流程

当你在一次操作时，需要更新 10 个`DOM`节点，浏览器没这么智能，收到第一个更新`DOM`请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程

而通过`VNode`，同样更新 10 个`DOM`节点，虚拟`DOM`不会立即操作`DOM`，而是将这 10 次更新的`diff`内容保存到本地的一个`js`对象中，最终将这个`js`对象一次性`attach`到`DOM`树上，避免大量的无谓计算

> 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUIkey

## **absolute 没有 relative 的时候参考谁定位** **body**

## HTTP 与 HTTPS 的区别

超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

**一、HTTP 和 HTTPS 的基本概念**

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**二、HTTP 与 HTTPS 有什么区别？**

HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。

HTTPS 和 HTTP 的区别主要如下：

1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。

2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。

3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

**三、HTTPS 的工作原理**

我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。

![HTTP与HTTPS的区别-马海祥博客](http://www.mahaixiang.cn/uploads/allimg/1507/1-150H120343I41.jpg)

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。

（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。

（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。

（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

（5）Web 服务器利用自己的私钥解密出会话密钥。

（6）Web 服务器利用会话密钥加密与客户端之间的通信。

![img](https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif)

**四、HTTPS 的优点**

尽管 HTTPS 并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但 HTTPS 仍是现行架构下最安全的解决方案，主要有以下几个好处：

（1）使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

（2）HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

（3）HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

（4）谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。

**五、HTTPS 的缺点**

虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：

（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；

（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

（4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。

（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

**六、http 切换到 HTTPS**

如果需要将网站从 http 切换到 https 到底该如何实现呢？

这里需要将页面中所有的链接，例如 js，css，图片等等链接都由 http 改为 https。例如：http://www.baidu.com改为https://www.baidu.com

BTW，这里虽然将 http 切换为了 https，还是建议保留 http。所以我们在切换的时候可以做 http 和 https 的兼容，具体实现方式是，去掉页面链接中的 http 头部，这样可以自动匹配 http 头和 https 头。例如：将http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。

## hash 模式和 history 模式

vue-router 中 hash 模式和 history 模式。

在 vue 的路由配置中有 mode 选项，**最直观的区别就是在 url 中 hash 带了一个很丑的 # ，而 history 是没有#的**。vue 默认使用 hash。

mode:"hash";  
mode:"history";

**hash** —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.aaa.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但**不会被包括**在 **HTTP 请求**中，对**后端完全没有影响**，因此改变 hash 不会重新加载页面。

**history** —— 利用了 HTML5 History Interface 中新增的 **pushState()** 和 **replaceState(**) 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。

因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。

history 模式的问题 通过 history api，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，**就怕刷新**，f5，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的。 在 hash 模式下，前端路由修改的是#中的信息，而浏览器请求时不会将 # 后面的数据发送到后台，所以没有问题。但是在 history 下，你可以自由的修改 path，当刷新时，如果服务器中没有相应的响应或者资源，则会刷新出来 404 页面。

## VUE2 和 VUE3 的区别

利用新的语言特性(es6)，解决了架构问题

**速度更快**

传统的 SPA 单一页面响应，即客户端渲染的模式

Vue.js 构建的应用程序，默认情况下是有一个 html 模板页，然后通过 webpack 打包生成一堆 js、css 等等资源文件。然后塞到 index.html 中

用户输入 url 访问页面 -> 先得到一个 html 模板页 -> 然后通过异步请求服务端数据 -> 得到服务端的数据 -> 渲染成局部页面 -> 用户

这样一来，必然延长了首屏加载的时间

SSR（服务端渲染）可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

简单点说：就是将页面在服务端渲染完成后在客户端直接显示。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。

**体积减少**

`可摇树优化,按需加载`

通过`webpack`的`tree-shaking`功能，可以将无用模块“剪辑”，仅打包需要的模块

能够`tree-shaking`，有两大好处：

- 对开发人员，能够对`vue`实现更多其他的功能，而不必担忧整体体积过大
- 对使用者，打包出来的包体积变小了

`vue`可以开发出更多其他的功能，而不必担忧`vue`打包出来的整体体积过多

摇树是一种消除死代码的方法。这个词最初是由 Rollup 发起的，并逐渐流行开来，但消除死代码的概念却早已存在。webpack 中也涉及了这个概念。应用程序的依赖项是树状结构。树中的每个节点都代表了一个依赖项，这些依赖项为应用程序提供了不同的功能。我们通过消除不需要的依赖项来减少树的节点。这个过程叫摇树。早期我们开发的应用程序依赖项比较少(树苗)，随着后续的开发树节点越来越多且有很多的节点我们可能已经不需要了(树老化了)。

**vue3 相比 vue2 很大的区别就是不是每一个模块都引入，例如说 vuex 中的 store 和 vue-router，之前都是直接使用 this，现在是当你的组件中需要用到的时候才会引用**

**更易维护**

**compositon Api**

- 可与现有的`Options API`一起使用
- 灵活的逻辑组合与复用
- `Vue3`模块可以和其他框架搭配使用

**更接近原生**

可以自定义渲染 API

**重写了虚拟`Dom`实现**

在 Vue2.0 当中，当数据发生变化，它就会新生成一个 DOM 树，并和之前的 DOM 树进行比较，找到不同的节点然后更新。但这比较的过程是全量的比较，也就是每个节点都会彼此比较。但其中很显然的是，有些节点中的内容是不会发生改变的，那我们对其进行比较就肯定消耗了时间。所以在 Vue3.0 当中，就对这部分内容进行了优化：在创建虚拟 DOM 树的时候，会根据 DOM 中的内容会不会发生变化，添加一个静态标记。那么之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。

`key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

**更好的 Typescript 支持**

`VUE3`是基于`typescipt`编写的，可以享受到自动的类型定义提示

## Vue3 中生命周期函数的变化

我们知道，在每个组件在被创建时，要经过一系列的初始化过程，比如，需要设置数据监听、编译模板、实例挂载并在数据变化时触发`DOM`更新等。

在`Vue2`中提供了生命周期钩子函数，如`beforeCreate` 、`created` 、`beforeMount` 、`mounted` 、`beforeUpdate`、`updated`、`beforeDestory`、`destoryed`等，用于在组件不同阶段执行一些我们想要的执行的操作

到了`Vue3`，有所变化

1. `beforeCreate ---->setup`
2. `created ---->setup`
3. `beforeMount ---->onBeforeMount`
4. `mounted ---->onMounted`
5. `beforeUpdate ---->onBeforeUpdate`
6. `updated ---->onUpdated`
7. `beforeDestory ---->onBeforeUnmount`
8. `destoryed ---->onUnmounted`

可以看到，`setup` 函数代替了 `beforeCreate`和`created` 两个生命周期函数，因此我们认为 setup 的执行时间在`beforeCreate` 和`created` 之间

为了更好的`Tree-shaking`，`Vue3`的生命周期函数都是从 `vue` 中导入，再进行直接调用

```jsx
//从 vue 中引入 多个生命周期函数
import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, unMounted } from 'vue'
export default {
	name: 'App',
	setup() {
		onBeforeMount(() => {
			// 在挂载前执行
		})
		onMounted(() => {
			// 在挂载后执行
		})
		onBeforeUpdate(() => {
			// 在更新前前执行
		})
		onUpdated(() => {
			// 在更新后执行
		})
		onBeforeUnmount(() => {
			// 在组件销毁前执行
		})
		unMounted(() => {
			// 在组件销毁后执行
		})
		return {}
	}
}
```

以上就是 Vue3 中生命周期函数的一点变化！
