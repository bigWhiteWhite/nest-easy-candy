# 前端笔记

## ES6 使用 require 引入图片

静态路径引入

```js
var imgUrl = require('../images/001.png')
```

不能使用动态路径引入图片，会报错

```js
var ImgSrc = '../images/001.png'
var img = require(ImgSrc)
```

因为 require 是打包工具所需要的标识，你写成运行时通过变量定义，是无法获取到，没办法打包。

require()写入的必须是 path

```js
 1. var imgSrc = "001.png";
require("../../asset/images/" + imgSrc);
 2. var imgName = "001";
require(`../../asset/images/${imgName}.png`);
```

## forin 的循环顺序

不一定根据定义时的顺数输出，所有浏览器的最新版本现在都按 chrome 执行，先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。

## tabIndex

**tabindex**指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用 Tab 键，因此得名）。

它接受一个整数作为值，具有不同的结果，具体取决于整数的值：

- tabindex=负值 (通常是 tabindex=“-1”)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用 JS 做页面小组件内部键盘导航的时候非常有用。
- `tabindex="0"` ，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的 DOM 结构来决定的。
- tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序按照**tabindex** 的数值递增而滞后获焦。如果多个元素拥有相同的 **tabindex**，它们的相对顺序按照他们在当前 DOM 中的先后顺序决定。

## 事件循环

浏览器是多线程的，但是 JS 是异步单线程

1. **GUI 渲染线程（DOM/BOM）**
2. **JS 引擎线程（web worker）**
3. **浏览器事件线程（onclick）**
4. 定时器触发线程
5. http 异步线程
6. EventLoop（事件循环）处理线程

```html
<body>
	<button id="button">button</button>
	<script>
		const button = document.getElementById('button')
		button.addEventListener('click', () => {
			Promise.resolve().then(() => {
				console.log('m1')
			})
			console.log('l1')
		})
		button.addEventListener('click', () => {
			Promise.resolve().then(() => {
				console.log('m2')
			})
			console.log('l2')
		})
	</script>
</body>
// 两个click都是宏任务,不关联 // l1 // m1 // l2 // m2
```

```html
<body>
	<button id="button">button</button>
	<script>
		const button = document.getElementById('button')
		button.addEventListener('click', () => {
			Promise.resolve().then(() => {
				console.log('m1')
			})
			console.log('l1')
		})
		button.addEventListener('click', () => {
			Promise.resolve().then(() => {
				console.log('m2')
			})
			console.log('l2')
		})
		button.click()
	</script>
</body>
// 模拟浏览器点击 执行整个宏任务13行开始执行,触发4 9两个click(同步),click执行完后13行结束,进微任务 // l1 // l2 // m1 // m2
```

## axios 参数格式化 get 请求传递数组

axios 发起 get 请求需要传递 params 参数作为 URL 参数。

如果 params 中包含数组，则 Request URL 表现形式形为`https://xxxx/get?arr[]=1&arr[]=2`。

如果想要其格式为`https://xxxx/get?arr=1&arr=2`，则需要手动做序列化，axios 有专门的配置项用作 params 序列化

```js
// `paramsSerializer` 是一个负责 `params` 序列化的函数
// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
paramsSerializer: function(params) {
	return Qs.stringify(params, {arrayFormat: 'repeat'})
},
```

qs 序列化参数

```js
qs.stringify({ids: [1, 2, 3]}, { indices: false })
//  ids=1&ids=2&ids=3

qs.stringify({ids: [1, 2, 3]}, { indices: true })
//  ids[0]=1&ids[1]=2&id[2]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘repeat‘})
// ids=1&ids=2&ids=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘brackets‘})
 // ids[]=1&ids[]=2&ids[]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘indices‘})
// ids[0]=1&ids[1]=2&ids[2]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘comma‘})
// ids[0]=1&ids[1]=2&ids[2]=3
```

## pointer-events 和 cursor

如果使用`pointer-evnets:none;`则该元素及其后代元素的`cursor`配置不生效，其鼠标样式为默认样式。但是如果该元素的后代元素的`pointer-events`为其他值时，则鼠标事件可以指向该后代元素。

## 强调内容的标签

`q标签`，将文本内容用`""`包含起来

`blockquote标签`表示其中文字为引用，渲染时会有一定缩进

`mark标签`突出高亮显示文字，渲染效果同常用浏览器的`crtl + F `。除此外，语法高亮通常使用`strong标签`配合 css 语法来实现定制化。

## 弹性布局末行对齐的应对方法（宫格）

[让 CSS flex 布局最后一行列表左对齐的 N 种方法 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2019/08/css-flex-last-align/)

[伪类匹配列表数目实现微信群头像 CSS 布局的技巧 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2019/03/nth-last-child-css-layout/)

## Referer

**`Referer`** 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 `Referer` 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。

在以下两种情况下，`Referer` 不会被发送：

- 来源页面采用的协议为表示本地文件的 "file" 或者 "data" URI；
- 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）。

作用：

1. 防盗链
2. 防止恶意请求

[http 请求头中 Referer 的含义和作用*小刘学安卓的博客-CSDN 博客*请求头中的 referer](https://blog.csdn.net/liuqinhou/article/details/126224164)

[Window.open() - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open)

[Referrer Policy 介绍 | JerryQu 的小站 (imququ.com)](https://imququ.com/post/referrer-policy.html)

[Referrer Policy 介绍「续」 | JerryQu 的小站 (imququ.com)](https://imququ.com/post/referrer-policy-2.html)

[referrer 策略和 meta 标签的问题\_thlzjfefe 的博客-CSDN 博客\_referrer 策略](https://blog.csdn.net/thlzjfefe/article/details/123538564)

## window.open

在 https 协议下，window.open 打开 http 链接在浏览器上失败，部分设备未复现，可能和浏览器版本或浏览器本地安全策略有关。

[window.open 前端下载文件，被拦截 或者显示无法安全下载问题\_Qlily_ing 的博客-CSDN 博客](https://blog.csdn.net/Qlily_ing/article/details/109054974)

https://blog.csdn.net/qq_41784169/article/details/117423654

https://blog.csdn.net/fjh1997/article/details/113624138

[https 下使用 window.open()或 a 标签下载文件失败的问题 - 简书 (jianshu.com)](https://www.jianshu.com/p/3a74ac9088b9)

## a 标签下载文件

a 标签的 download 属性指示浏览器下载 URL 而不是导航到它，同源 URLs 才会生效，如果 href 的值是非同源 url 则还是跳转。

非同源 URLs 和某些文件比如`.png .excel`等受制于浏览器可能会直接打开预览而不是下载，可以考虑在 href 属性值末尾添加`?response-content-type=application/octet-stream`

https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a

https://blog.csdn.net/love_aya/article/details/115211470

https://blog.csdn.net/m0_63947499/article/details/127739586

## 响应式布局

常用响应式尺寸划分：

1.超小屏幕（手机，小于 768px） 2.小屏幕（平板，大于等于 768px） 3.中等屏幕（桌面显示器，大于等于 992px） 4.大屏幕（大桌面显示器，大于等于 1200px）

# JSON.stringify

## 参考文献：

[你会用 JSON.stringify()?](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247493740&idx=1&sn=b7b42aa25c5a366e62d596dcb142dd28&chksm=c06569faf712e0ec424babcc36475de32a7b667f845eacfb60c7a1524e3db4d65e1298822685&scene=132#wechat_redirect)

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)

## 语法

> JSON.stringify(value[, replacer [, space]])

### **参数**

- `value`

  将要序列化成 一个 JSON 字符串的值。

- `replacer` 可选

  如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

- `space` 可选

  指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

### 第二个参数--过滤器

**如果第二个参数是一个数组**，那么`JSON.stringify()`返回的结果只会包含该数组中列出的对象属性。比如下面的例子：

```js
let json1 = {
	title: 'Json.stringify',
	author: ['浪里行舟'],
	year: 2021,
	like: 'frontend',
	weixin: 'frontJS'
}
let jsonText = JSON.stringify(json1, ['weixin'])
```

在这个例子中，JSON.stringify()方法的第二个参数是一个包含一个字符串的数组："weixin"。它对应着要序列化的对象中的属性，因此结果 JSON 字符串中只会包含这个属性：

```JSON
"{"weixin":"frontJS"}"
```

**如果第二个参数是一个函数**，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串。

```js
const students = [
	{
		name: 'james',
		score: 100
	},
	{
		name: 'jordon',
		score: 60
	},
	{
		name: 'kobe',
		score: 90
	}
]

function replacer(key, value) {
	if (key === 'score') {
		if (value === 100) {
			return 'S'
		} else if (value >= 90) {
			return 'A'
		} else if (value >= 70) {
			return 'B'
		} else if (value >= 50) {
			return 'C'
		} else {
			return 'E'
		}
	}
	return value
}
console.log(JSON.stringify(students, replacer, 4))
```

上面的代码，我们通过 replacer 将成绩从百分制替换为成绩等级。

![图片](imgs\640-1620367180525)

如果 stringify 的第二个参数为函数，且它的返回值**如果是 undefined，那么对应的属性不会被序列化**，如果返回其他的值，那么用返回的值替代原来的值进行序列化。

## toJSON()--自定义 JSON 序列化

**有时候，对象需要在`JSON.stringify()`之上自定义 JSON 序列化**。此时，可以在要序列化的对象中添加`toJSON()`方法，序列化时会基于这个方法返回适当的 JSON 表示。

下面的对象为自定义序列化而添加了一个 toJSON()方法：

```js
let json1 = {
	title: 'Json.stringify',
	author: ['浪里行舟'],
	year: 2021,
	like: 'frontend',
	weixin: 'frontJS',
	toJSON: function () {
		return this.author
	}
}
console.log(JSON.stringify(json1)) // ["浪里行舟"]
```

注意，**箭头函数不能用来定义 toJSON()方法**。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。

## 使用场景

### 判断对象是否相等

可以使用`JSON.stringify()`方法,来判断两个对象是否相等。

```js
// 判断对象是否相等
let obj1 = {
	a: 1,
	b: 2
}
let obj2 = {
	a: 1,
	b: 2
}
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)) // true
```

不过这种方式存在着较大的局限性，**对象如果调整了键的顺序，就会判断出错！**

```js
// 调整对象键的位置后
let obj1 = {
	a: 1,
	b: 2
}
let obj2 = {
	b: 2,
	a: 1
}
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)) // false
```

### 对象深拷贝

这种方法虽然可以实现数组或对象深拷贝,**但不能处理函数和正则**，因为这两者基于`JSON.stringify`和`JSON.parse`处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为`null`）了。

## 注意事项

有些属性无法被 stringify

- NaN 和 Infinity 格式的数值及 null 都会被当做 null

- 被转换值中有 undefined、任意的函数以及 symbol 值（不是键而是键值）

  - 数组中的`undefined`、任意的函数以及`symbol`值在序列化的过程中会被转换成 `null`

    ```js
    JSON.stringify([undefined, function () {}, Symbol('')])
    // '[null,null,null]'
    ```

  - 非数组中的`undefined`、任意的函数以及`symbol`值在序列化的过程中会被忽略

    ```js
    JSON.stringify({ x: undefined, y: function () {}, z: Symbol('') })
    // '{}'
    ```

  - 函数、undefined 被单独转换时，会返回 undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`.

- 循环引用

  如果一个对象的属性值通过某种间接的方式指回该对象本身，那么就是一个循环引用。比如：

  ```js
  let bar = {
  	a: {
  		c: foo
  	}
  }
  let foo = {
  	b: bar
  }

  JSON.stringify(foo)
  ```

  这种情况下，序列化会报错的：

  ```js
  // 错误信息
  Uncaught ReferenceError: foo is not defined
      at <anonymous>:3:8
  ```

- 含有不可枚举的属性值

  不可枚举的属性默认会被忽略：

  ```js
  let personObj = Object.create(null, {
  	name: { value: '浪里行舟', enumerable: false },
  	year: { value: '2021', enumerable: true }
  })

  console.log(JSON.stringify(personObj)) // {"year":"2021"}
  ```
